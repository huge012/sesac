12/10

▶ 스택 : 변수명을 저장하고 있는 메모리. 변수를 할당하고 힙의 특정 주소를 가리켜 별명을 지어줌
힙 특징 : 변수명이 없는 메모리 할당, 변수명이 없어서 접근을 못함. new 라는 키워드로 만들어지는 변수는 전부 힙에 저장됨

-> 힙을 바로 접근할 수 없음, 스택에 만드는 변수(참조 변수)가 힙의 주소를 데리고 있음

▶ 배열 : 힙에 만들어지는 연속적인 공간, 배열 크기가 정해지는 순간 바꿀 수 없음 (바꾸고 싶으면 동적 배열 사용)


▶ Arrays.toString(배열명) <- 배열 속에 있는 모든 요소를 묶어줌

1) [원소값, 원소값, 원소값, ...] <- 출력용

int[] nums = new int[5];
nums[0] = 3
nums[1] = 5
다른 공간은 사용하기 전까지 낭비되는 중

ArrayList<Integer> nums = new ArrayList<Integer>();
nums.add(10);
nums.add(20);
add 할 때마다 하나씩 연결됨


어레이리스트 = 유동적으로 크기가 변함



---


▶ 쉘 스크립트 
grep root-test /etc/passwd

cd, echo, printf <- 쉘 내장 명령어

▶ echo : 뒤에 오는 문장 출력
▶ printf : 뒤에 오는 단어만 출력, 문장 출력하려면 "" 안에 작성.
 printf "%d + %d = %d" 10 20 30   (변수 들어감)

▶ cp *.txt ..  <- 모든 파일 중 .txt인 애들을 ..폴더로 카피

▶ ls 옵션
ls *.txt <- .txt인 파일 전부 보여줌
ls aa?.txt <- aa( ).txt 라는 파일 찾음 (파일명은 3글자, 앞 두글자가 aa여야함)
ls [abcd].txt <- a, b, c, d로 이루어진 파일명을 찾음
ls [a-z]* <- 소문자로 이루어진 파일, 디렉토리 찾음
ls [a-z]*.* <- 소문자로 이루어진 파일 (확장자 있는) 찾음

▶ 특수문자
* : 0개 이상의 문자
? : 1개 문자
[] : [A-Za-z]??[0-9]
~ : 루트 디렉토리
- : 마지막 작업했던 디렉토리
\ : 특수문자를 일반문자취급하게 해줌

"" <- $, \, 공백 을 제외한 쉘의 특수문자를 무시하고 출력
'' <- 쉘의 특수문자를 무시하고 출력


▶ 리디렉션(표준입출력의 방향을 바꿈. 출력 결과를 다른 파일에 입력시킴)
ls -l > list.txt  <<- 덮어쓰기 됨
date >> outfile <<- 이어쓰기 됨

set -o noclobber << 덮어쓰기 금지 옵션
set +o noclobber << 덮어쓰기 가능 옵션

▶ VAR01=test <<- 쉘 변수 만들어줌

▶ export 환경변수명=값 << 환경변수 만들어줌

▶ export -n 환경변수명 <<- 환경변수를 쉘변수로 바꿈

▶ 쉘 스크립트 확장자 .sh
#!/bin/sh  <<- 배쉬 쓴다는 의미
sh test.sh <<- 쉘 스크립트 실행

▶ 권한
.sh파일 ls -al로 확인 시, -rw-rw-r--  <<- 소유주, 소유주와 같은 그룹은 읽기,쓰기 가능. 외에는 읽기만 가능

chmod  777 파일명 <- 권한 수정
chmod +x 파일명 <- 실행권한을 다 줌
실행권한이 다 있으면 bash로 실행하지 않고 ./파일명.sh 만 쳐도 알아서 실행됨


--

▶ 변수
변수명 : 스페이스x 숫자도 문자열로 인식, 대소문자 구분.
터미널에 (변수명)=내용 쓰면 바로 생성됨

#!/bin/sh

num1=100
num2=$num1+200   <<- 문자열끼리 이어줘서 100+200이라는 문자열이 됨
echo $num1
echo $num2

exit 0


▶ 산술연산
산술연산을 하기 위해서는 `expr 숫자 + 숫자`
* 연산자 : 특수기호로 인식될 수 있기때문에 곱하기로 사용하기 위해서는 \(역슬래시)를 붙여줌

`expr \( 3 + 4 \) \* 5`   (괄호와 곱셈은 역슬래시 써줘야함)

 $0	$1  $2
./exam03 aaa 10   <- 실행파일 뒤에 들어오는 데이터 : 파라미터


▶ 여러줄 주석
<<"END"

END

▶ if문

if [ 조건 ]
then
	참일 때 문장
else
	거짓일 때 문장
fi

둘이 같은지 비교
(변수) -eq (변수)
(변수) = (변수)


-e (파일명)   <- 파일이 존재하면 true 존재하지 않으면 false

▶ switch case문
case 변수 in
	값1)
		문장실행
		문장실행;;
	값2)
		문장실행;;
	값3)
		문장실행;;
	...
	*)
		위에서 선택이 안되는 경우 실행;;
esac


yes | y | Y | Yes | YES)  < 다양한 조건 넣을 수 있음
[nN*]) <<- n이나 N으로 시작되는 변수



▶ for ... do ... done

for i in 1 2 3 4 5
do
	echo $i
done

▶ while [ 조건 ] 
do
	 반복할 문자
done

▶ until [ whrjs ] # 조건이 참일때까지 반복
do
	반복할 문자
done


▶ seq 1 5
1~5 숫자 뽑아냄

`seq 1 2 10`  <- 1부터 2칸씩 뛰어넘음



▶ 함수로 합 구하기

func() {
	echo "Hello World"
}

sumnum() {
	local sum=`expr $1 + $2` # local = 해당 함수에서만 사용
	echo "sumnum 총합 : $sum"
	return $sum
}

func
sumnum 3 5
echo "총합 : $?"


exit 0