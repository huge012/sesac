# -*- coding: utf-8 -*-
"""01. 통계분석시각화 - 응용.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H2uzO2s3lj3aHhR7PA4dnozXSeSrWRTZ

- 파이참 설치 및 모듈 설치 방법

- Json, XML to Pandas

- 워드 클라우드

- 타이타닉.csv 파일 분석 및 시각화
"""

import urllib.request

url = 'https://dapi.kakao.com/v3/search/book'  # OpenAPI 서비스 제공 URL

# 전달 인자
target_param = "target=title"
query_in = input("검색 질의 : ")
page_param = "page=1"
query_param = "query="+urllib.parse.quote(query_in) # utf-8로 인코딩

# 쿼리
query_str = url+'?'+target_param+'&'+query_param+'&'+page_param
print(query_str)

# 서비스 요청에 사용할 객체를 생성
request = urllib.request.Request(query_str)
# request.add_header("Authorization", "KakaoAK 	REST KEY") # RESTAPI 키 입력
request.add_header("Authorization", "KakaoAK 20b1e756b870ef9cd5ea0bb96cbcbd5c") # RESTAPI 키

# 웹 서버에 요청
response = urllib.request.urlopen(request)
res = response.read().decode('utf-8')
print(res)

import json
jd = json.loads(res)
print(jd)

import pandas as pd

df = pd.json_normalize(jd['documents'])  # json 파일 내 특정 키에 대한 정보를 가져옴
df.info()

import urllib.request

# url
url = 'https://openapi.naver.com/v1/search/book.xml'

# 전달인자
query_in = input("검색 질의 : ")
query_param = "query="+urllib.parse.quote(query_in) # utf-8로 인코딩

# 쿼리 문자열
query_str = url+'?'+query_param
print(query_str)

# 서비스 요청에 사용할 객체 생성
request = urllib.request.Request(query_str)
# request.add_header('X-Naver-Client-Id', '발급받은 client ID 값')
request.add_header('X-Naver-Client-Id', '_KZP47_jdTdi_UkqtXXs')
# request.add_header('X-Naver-Client-Secret', '발급받은 client secret 값') 
request.add_header('X-Naver-Client-Secret', 'UzKAmeafKx')

# 서비스 요청
response = urllib.request.urlopen(request)
res = response.read().decode('utf-8')
print(res)

df = pd.read_xml(res, xpath=".//item")
df.info()

import matplotlib.pyplot as plt
df.price.plot()
plt.show()

des_str = df.description[0]
des_str

# 특수문자 제거
demo_str = "abc 123 cae$ asd# cr"
target_str = ""
for ch in demo_str:
  if ch.isalnum() or ch.isspace():
    target_str += ch
print(target_str)
target_str = "".join(char for char in demo_str if (char.isalnum() or char.isspace())) # for문 확인하여 조건이 맞을 경우 join 실행
print(target_str)

filter_str = "".join(char for char in des_str if (char.isalnum() or char.isspace()) or char != 'ㆍ')
print(filter_str)
words = filter_str.split(' ')
s = pd.Series(words)
s.value_counts()

from wordcloud import WordCloud

src = """
Python can be easy to pick up whether you're a first time programmer or you're experienced with other languages. The following pages are a useful first step to get on your way writing programs with Python!
The community hosts conferences and meetups, collaborates on code, and much more. Python's documentation will help you along the way, and the mailing lists will keep you in touch.
The Python Package Index (PyPI) hosts thousands of third-party modules for Python. Both Python's standard library and the community-contributed modules allow for endless possibilities.
Python is developed under an OSI-approved open source license, making it freely usable and distributable, even for commercial use. Python's license is administered by the Python Software Foundation.
"""

src = """
파이썬[2](영어: Python)은 1991년[3] 네덜란드계 프로그래머인 귀도 반 로섬[4]이 발표한 고급 프로그래밍 언어로, 플랫폼에 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typed) 대화형 언어이다. 파이썬이라는 이름은 귀도가 좋아하는 코미디 〈Monty Python's Flying Circus〉에서 따온 것이다. 이름에서 고대신화에 나오는 커다란 뱀을 연상하는 경우도 있겠지만, 이와는 무관하다. 다만 로고에는 뱀 두마리가 형상화 되어 있다.
파이썬은 비영리의 파이썬 소프트웨어 재단이 관리하는 개방형, 공동체 기반 개발 모델을 가지고 있다. C언어로 구현된 사이썬 구현이 사실상의 표준이다.
파이썬 3.9 버전 이상부터는 64비트로 바뀌면서 32비트 컴퓨터에서 사용할 수 없다. 파이썬 3.9 버전 이상을 사용하려면 64비트 컴퓨터여야 한다.
"""

wc = WordCloud()
wc.generate(src)
plt.imshow(wc)
plt.axis('off')
plt.show()
wc.words_

!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

import matplotlib.font_manager as fm
sf = fm.findSystemFonts()
[f for f in sf if 'Nanum' in f]

wc = WordCloud(font_path = '/usr/share/fonts/truetype/nanum/NanumBarunGothic.ttf')
wc.generate(filter_str)
plt.figure()
plt.imshow(wc)
plt.axis('off')
plt.show()
wc.words_

"""TF : Term Frequency, 단어가 얼마나 자주 나오는가(빈도)

IDF : Inverse Document Frequency, 검색하는 단어가 포함된 문서가 몇 개나 있는가(희귀성)

웹페이지 중 일부만 뽑아냄 : 웹 스크래핑

웹페이지 전체를 가져옴 : 웹 크로울링

BeautifulSoup 이용 시 디테일한 핸들링 가능
"""

from bs4 import BeautifulSoup
url = 'https://ehpub.co.kr'  # 사이트 주소

response = urllib.request.urlopen(url)  # 웹 서버에 요청
res = response.read().decode('utf-8')

hre = BeautifulSoup(res, 'html.parser')

wc = WordCloud(font_path = '/usr/share/fonts/truetype/nanum/NanumBarunGothic.ttf')
wc.generate(hre.body.text)
plt.figure()
plt.imshow(wc)
plt.axis('off')
plt.show()

"""#타이타닉 파일 분석 실습


"""

path = '/content/drive/MyDrive/seSac/python/train_titanic.csv'
df = pd.read_csv(path)
df

"""1. 주어진 자료의 인원, 생존자, 사망자는 몇 명인가?"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

ls = np.array(df['Survived'])
total = np.size(ls)
survived = np.sum(ls)
dead = total - survived
print(f"총원 : {total}, 생존자 : {survived}, 사망자 : {dead}")

# 강사님 풀이
sur_data = df['Survived']
svc = sur_data.value_counts()
print(f"사망자 수 : {svc.values[0]}, 생존자 수 : {svc.values[1]}")
print(f"총원 : {sur_data.count()}")

"""2. 생존자와 사망자를 Pie 그래프로 나타내고 생존자와 사망자의 퍼센트를 소수점 2자리까지 나타내시오.

"""

ratio = [survived, dead]
labels = ['servived', 'dead']
color = ['#ffc000', 'darkgray']
wedgeprops = {'width':0.7, 'edgecolor':'w', 'linewidth':5}
plt.pie(ratio, labels=labels, autopct="%.2f%%", counterclock=False, colors=color, wedgeprops=wedgeprops)
plt.show()

# 강사님 풀이
labels = ["dead", "alive"]
plt.pie(svc, labels=labels, autopct="%.2f%%")
plt.show()

"""3. 결측데이터가 있는 컬럼들을 조사하시오. (각 컬럼마다 결측 데이터가 얼마나 있는지)"""

cn = ['PassengerId', 'Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Ticket', 'Fare', 'Cabin', 'Embarked']
for column in cn:
  cnt = df[column].isnull().sum()
  if (cnt > 0):
    print(f"[ {column} ] 컬럼 결측 데이터 개수 : {cnt}")

# 강사님 풀이
print(df['Age'].isnull().value_counts())
print(df['Cabin'].isnull().value_counts())
print(df['Embarked'].isnull().value_counts())

"""4. Pclass의 종류별로 분포를 Pie 그래프로 나타내시오."""

class_data = df['Pclass']
ratio = class_data.value_counts()
# ratio = df[['Pclass', 'Survived']].groupby(['Pclass']).count()
labels = ['3 class', '1 class', '2 class']
color = ['#ffc000', '#8fd9b6', '#ff9999']
wedgeprops = {'width':0.7, 'edgecolor':'w', 'linewidth':5}
plt.pie(ratio, labels=labels, autopct="%.2f%%", counterclock=False, colors=color, wedgeprops=wedgeprops)
plt.show()

# 강사님 풀이
dvc = df.Pclass.value_counts().sort_index()
plt.pie(dvc.values, autopct="%.2f%%")
plt.title("Pclass")
plt.show()

"""5. Pclass의 종류별로 생존자와 사망자를 하나의 막대그래프로 나타내시오.(아래:생존자, 위:사망자, 나란히 병행하는 것도 해보기)"""

cn = df[['Pclass', 'Survived']].groupby(['Pclass']).count()
class_alived = df[['Pclass', 'Survived']].groupby(['Pclass']).sum()

# 해당 코드는 seaborn의 countplot 써서 분석

# 강사님 코드
pdata = df.Pclass
cn = len(pdata.unique())
pc_alive_arr = np.zeros(3)
pc_dead_arr = np.zeros(3)
for index in range(len(pdata)):
  pi = pdata[index] - 1  # Pclass는 1, 2, 3인데 이를 0, 1, 2로 변환
  if sur_data[index] == 0:  # 죽은 승객일 때
    pc_dead_arr[pi] += 1
  else:  # 생존 승객일 때
    pc_alive_arr[pi] += 1
pc_alive_arr, pc_dead_arr

labels = ['1', '2', '3']
plt.bar(labels, pc_alive_arr)
plt.bar(labels, pc_dead_arr, bottom=pc_alive_arr)
for i in range(cn):
  plt.annotate(str(pc_alive_arr[i]), (-0.1+i, 40))
  plt.annotate(str(pc_dead_arr[i]), (-0.1+i, pc_alive_arr[i]+30))
plt.show()

"""6. Name 컬럼에 탑승자를 부르는 호칭을 Mr, Mrs, Miss, Master, Dr, ETC로 나누어 분포를 파이 그래프로 나타내시오."""

names_values = ['Mr', 'Mrs', 'Miss', 'Master', 'Dr', 'ETC']
ndata = df['Name']
name_arr = np.zeros(6)

# 각 이름마다 체크
for ne in ndata:
  # ','를 기준으로 분리
  f, s = ne.split(',')

  # ',' 뒤에 있는 문자열을 '.'으로 분리
  ses = s.split('.')

  # '.'의 앞부분에 공백 제거
  s0 = ses[0].replace(' ', '')

  # names_values에 있는지 체크
  check = False
  for i, ne2 in enumerate(names_values):
    # 호칭 있을 경우 출력
    if ne2 == s0:
      name_arr[i] += 1
      check = True
      break

  # 호칭 없을 경우
  if check == False:
    name_arr[5] += 1

color = ['#ff9999', '#ffc000', '#8fd9b6', '#d395d0', 'lightgray']
wedgeprops = {'width':0.8, 'edgecolor':'w'}
plt.pie(name_arr, labels=names_values, autopct="%.2f%%", counterclock=False, colors=color, wedgeprops=wedgeprops)
plt.show()
print(name_arr)

# 강사님 풀이
names_values = ['Mr', 'Mrs', 'Miss', 'Master', 'Dr', 'ETC']
def get_name_index(name):
  first, second = name.split(',')  # ',' 기준 분리
  foos = second.split('.')  # '.' 기준 분리
  tn = foos[0].replace(' ', '')  # 공백 제거
  for index, nv in enumerate(names_values):
    if nv == tn :
      return index
  return 5

n_cnts = np.zeros(6)
for i, name in enumerate(df.Name):
  ni = get_name_index(name)
  n_cnts[ni] += 1
print(n_cnts)

plt.pie(n_cnts, labels=names_values, autopct="%.2f %%")
plt.title("Name")
plt.show()

"""7. 앞에서 구분한 호칭에 따른 생존자와 사망자를 하나의 막대그래프로 나타내시오.(아래:생존자, 위:사망자)"""

ndata = df.Name
names_values = ['Mr', 'Mrs', 'Miss', 'Master', 'Dr', 'ETC']
n_alive_arr = np.zeros(6)
n_dead_arr = np.zeros(6)

for index in range(len(ndata)):  # 이름마다 체크
  ne = ndata[index]
  f, s = ne.split(',')
  ses = s.split('.')
  s0 = ses[0].replace(' ', '')

  check = False
  for i, ne2 in enumerate(names_values):
    if ne2 == s0:  # 호칭 존재할 경우
      if sur_data[index] == 0:
        n_dead_arr[i] += 1
      else:
        n_alive_arr[i] += 1
      check = True
      break
  
  if check == False:
    if sur_data[index] == 0:
      n_dead_arr[-1] += 1
    else:
      n_alive_arr[-1] += 1

plt.bar(names_values, n_alive_arr)
plt.bar(names_values, n_dead_arr, bottom=n_alive_arr)
for i in range(6):
  plt.annotate(str(n_alive_arr[i]), (-0.2+i, 10))
  plt.annotate(str(n_dead_arr[i]), (-0.2+i, n_alive_arr[i]+30))
plt.show()

# 강사님 풀이
pn_alive_arr = np.zeros(6)
pn_dead_arr = np.zeros(6)

for i, name in enumerate(df.Name):
  ni = get_name_index(name)
  if sur_data[i] == 0:
    pn_dead_arr[ni] += 1
  else :
    pn_alive_arr[ni] += 1
plt.bar(names_values, pn_alive_arr)
plt.bar(names_values, pn_dead_arr, bottom=pn_alive_arr)
for i in range(6):
  plt.annotate(str(pn_alive_arr[i]), (-0.1+i, 40))
  if pn_alive_arr[i] < 40:
    plt.annotate(str(pn_dead_arr[i]), (-0.1+i, pn_alive_arr[i]+80))
  else:
    plt.annotate(str(pn_dead_arr[i]), (-0.1+i, pn_alive_arr[i]+30))
plt.show()

"""8. 성별로 분포를 파이 그래프로 나타내시오."""

sex_values = ['female', 'male']
s_total = np.zeros(2)
s_alive_arr = np.zeros(2)
s_dead_arr = np.zeros(2)

for person in df.Sex:
  if person == 'female':
    s_total[0] += 1
  else:
    s_total[1] += 1

color = ['#ff9999', '#ffc000']
wedgeprops = {'width':0.8, 'edgecolor':'w'}
plt.pie(s_total, labels=sex_values, autopct="%.2f%%", counterclock=False, colors=color, wedgeprops=wedgeprops)
plt.show()
print(s_total)

# 강사님 풀이
sex_values = ['female', 'male']
def get_sex_index(sex):
  if sex == 'female':
    return 0
  return 1

s_cnts = np.zeros(2)
for i, sex in enumerate(df.Sex):
  si = get_sex_index(sex)
  s_cnts[si] += 1
print(s_cnts)

plt.pie(s_cnts, labels=sex_values, autopct="%.2f %%")
plt.title("Sex")
plt.show()

# 강사님 풀이 (2)
svc = df.Sex.value_counts().sort_index()
plt.pie(svc.values, labels=['female', 'male'], autopct="%.2f %%", explode=[0.02, 0.02])
plt.title("Sex")
plt.show()

"""9. 성별에 따른 생존자와 사망자를 하나의 막대그래프로 나타내시오.(아래:생존자, 위:사망자)"""

s_dead_arr = np.zeros(2)
s_alive_arr = np.zeros(2)
for i, s in enumerate(df.Sex):
  if s == 'female':
    if sur_data[i] == 0:
      s_dead_arr[0] += 1
    else:
      s_alive_arr[0] += 1
  else:
    if sur_data[i] == 0:
      s_dead_arr[1] += 1
    else:
      s_alive_arr[1] += 1

plt.bar(sex_values, s_alive_arr)
plt.bar(sex_values, s_dead_arr, bottom=s_alive_arr)
for i in range(2):
  plt.annotate(str(s_alive_arr[i]), (-0.1+i, 80))
  plt.annotate(str(s_dead_arr[i]), (-0.1+i, s_alive_arr[i]+40))
plt.show()

# 강사님 풀이
sdata = df.Sex
sn = len(sdata.unique())
ps_alive_arr = np.zeros(sn)
ps_dead_arr = np.zeros(sn)
for index in range(len(sdata)):
  if sdata[index] == 'female':
    si = 0
  else:
    si = 1
  if sur_data[index] == 0:
    ps_dead_arr[si] += 1
  else :
    ps_alive_arr[si] += 1

labels = ['female', 'male']
plt.bar(labels, ps_alive_arr)
plt.bar(labels, ps_dead_arr, bottom=ps_alive_arr)
for i in range(sn):
  plt.annotate(str(ps_alive_arr[i]), (-0.1+i, 40))
  plt.annotate(str(ps_dead_arr[i]), (-0.1+i, pc_alive_arr[i]+30))
plt.show()

"""10. 나이를 5살 범위로 17단계로(0~5, 5~10,...,80~85)로 나누어 분포를 조사하여 파이 그래프로 나타내시오.(결측값은 평균나이로 처리하시오. 0 이상 5 미만)"""

ages_values = ['0~5', '5~10', '10~15', '15~20', '20~25', '25~30', '30~35', '35~40', '40~45', '45~50', '50~55', '55~60', '60~65', '65~70', '70~75', '75~80', '80~85']
ages = df.Age
ages = ages.fillna(ages.mean())
a_arr = np.zeros(17)

for i, a in enumerate(ages):
  a_arr[int(a//5)] += 1

wedgeprops = {'width':0.8, 'edgecolor':'w'}
plt.pie(a_arr, labels=ages_values, autopct="%.2f%%", counterclock=False, wedgeprops=wedgeprops)
plt.show()
print(a_arr)

# 강사님 풀이 (1)
# df.Age.isnull().value_counts() 결측데이터 있는지 확인
mv = df.Age.mean()  # 평균
ad = df.Age.fillna(mv)  # 결측치를 수정

n, bins, patches = plt.hist(ad, bins=[0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85])  # hist : 분포수 세기
plt.show()
n, bins, patches  # n : 누계, bins : 분포 구분, patches : 반복작업용 항목개수

# 강사님 풀이 (2)
age_values = np.zeros(17)
for i, age in enumerate(ad) :
  ai = age//5
  ai = int(ai)
  age_values[ai] += 1
age_values

plt.pie(age_values, labels=ages_values, autopct="%.2f %%")
plt.show()

"""11. 나이를 구분한 단계에 따른 생존자와 사망자를 하나의 막대그래프로 나타내시오.(아래:생존자, 위:사망자)"""

ac = len(ages_values)
a_alive_arr = np.zeros(ac)
a_dead_arr = np.zeros(ac)

for i, a in enumerate(ages):
  if(sur_data[i] == 0):
    a_dead_arr[int(a//5)] += 1
  else:
    a_alive_arr[int(a//5)] += 1

plt.bar(ages_values, a_alive_arr)
plt.bar(ages_values, a_dead_arr, bottom=a_alive_arr)
for i in range(ac):
  plt.annotate(str(a_alive_arr[i]), (-0.1+i, 40))
  if a_alive_arr[i] < 40:
    plt.annotate(str(a_dead_arr[i]), (-0.1+i, a_alive_arr[i]+80))
  else:
    plt.annotate(str(a_dead_arr[i]), (-0.1+i, a_alive_arr[i]+30))
plt.show()

# 강사님 풀이
pa_alive_arr = np.zeros(17)
pa_dead_arr = np.zeros(17)
for index in range(len(ad)):
  ai = ad[index]//5
  ai = int(ai)
    
  if sur_data[index] == 0:
    pa_dead_arr[ai] += 1
  else :
    pa_alive_arr[ai] += 1

plt.bar(ages_values, pa_alive_arr)
plt.bar(ages_values, pa_dead_arr, bottom=pa_alive_arr)
plt.show()
for i in range(17):
  print(f"{i*5:02d}  ~  {(i+1)*5:-02d}  :   {age_values[i]:3.0f}")

"""12. SibSp 컬럼의 값의 종류에 따른 분포를 조사하여 파이 그래프로 나타내시오."""

ssdata = df.SibSp.value_counts().sort_index()
ss_values = ['0', '1', '2', '3', '4', '5', '8']

wedgeprops = {'width':0.8, 'edgecolor':'w'}
plt.pie(ssdata.values, labels=ss_values, autopct="%.2f%%", counterclock=False, wedgeprops=wedgeprops)
plt.show()
print(ssdata)

# 강사님 풀이
svc = df.SibSp.value_counts().sort_index()
plt.pie(svc.values, labels=svc.index, autopct="%.2f%%")
plt.title("SibSp")
plt.show()

"""13. 값에 따른 생존자와 사망자를 하나의 막대그래프로 나타내시오.(아래:생존자, 위:사망자, 6~7 값도 그래프 그릴 때 고려해야 할 요소일듯)"""

ssn = len(ss_values)
ss_datas = df.SibSp
ss_alive_arr = np.zeros(ssn)
ss_dead_arr = np.zeros(ssn)

for index in range(len(ss_datas)):
  si = 0
  for i in range(ssn):
    if str(ss_datas[index]) == ss_values[i]:
      si = i
      break
  if sur_data[index] == 0:
    ss_dead_arr[si] += 1
  else :
    ss_alive_arr[si] += 1

ss_alive_arr, ss_dead_arr

plt.bar(ss_values, ss_alive_arr)
plt.bar(ss_values, ss_dead_arr, bottom=ss_alive_arr)
for i in range(ssn):
  plt.annotate(str(ss_alive_arr[i]), (-0.3+i, 40))
  if ss_alive_arr[i] < 40:
    plt.annotate(str(ss_dead_arr[i]), (-0.3+i, ss_alive_arr[i]+80))
  else:
    plt.annotate(str(ss_dead_arr[i]), (-0.3+i, ss_alive_arr[i]+30))
plt.show()
ss_alive_arr, ss_dead_arr

# 강사님 풀이
sdata = df.SibSp
sn = 9 # 형제 자매 수를 인덱스로 사용하기 위해서 0~8까지 9개를 사용
sc_alive_arr = np.zeros(sn)
sc_dead_arr = np.zeros(sn)
for index in range(len(sdata)):
  si = sdata[index]  # 형제 자매 수를 얻어온다
  if sur_data[index] == 0:  # 죽은 승객일 때
    sc_dead_arr[si] += 1
  else:  # 생존 승객일 때
    sc_alive_arr[si] += 1

labels = [str(i) for i in range(9)]
plt.bar(labels, sc_alive_arr)
plt.bar(labels, sc_dead_arr, bottom=sc_alive_arr)
for i in range(sn):
  plt.annotate(str(sc_alive_arr[i]), (-0.1+i, 40))
  if sc_alive_arr[i] < 40:
    plt.annotate(str(sc_dead_arr[i]), (-0.3+i, sc_alive_arr[i]+80))
  else:
    plt.annotate(str(sc_dead_arr[i]), (-0.3+i, sc_alive_arr[i]+30))
plt.show()

"""14. Parch 컬럼의 값의 종류에 따른 분포를 조사하여 파이 그래프로 나타내시오."""

pdata = df.Parch.value_counts().sort_index()
p_values = [0,1,2,3,4,5,6]

wedgeprops = {'width':0.8, 'edgecolor':'w'}
plt.pie(pdata.values, labels=p_values, autopct="%.2f%%", counterclock=False, wedgeprops=wedgeprops)
plt.show()
print(pdata)

"""15. 값에 따른 생존자와 사망자를 하나의 막대그래프로 나타내시오.(아래:생존자, 위:사망자)"""

pn = len(p_values)
p_datas = df.Parch
p_alive_arr = np.zeros(pn)
p_dead_arr = np.zeros(pn)

for i, p in enumerate(p_datas):
  if sur_data[i] == 0:
    p_dead_arr[p] += 1
  else :
    p_alive_arr[p] += 1

plt.bar(p_values, p_alive_arr)
plt.bar(p_values, p_dead_arr, bottom=p_alive_arr)
for i in range(pn):
  plt.annotate(str(p_alive_arr[i]), (-0.3+i, 40))
  if p_alive_arr[i] < 40:
    plt.annotate(str(p_dead_arr[i]), (-0.3+i, p_alive_arr[i]+80))
  else:
    plt.annotate(str(p_dead_arr[i]), (-0.3+i, p_alive_arr[i]+30))
plt.show()

p_alive_arr, p_dead_arr

"""16. 승선한 항구(Embarked 컬럼)에 따른 분포를 조사하여 파이 그래프로 나타내시오.(결측값은 'N'으로 마킹하시오.)"""

ed = df.Embarked.fillna('N')  # 결측치를 수정
ed = ed.value_counts()
ed_values = ['S', 'C', 'Q', 'N']

wedgeprops = {'width':0.8, 'edgecolor':'w'}
plt.pie(ed.values, labels=ed_values, autopct="%.2f%%", counterclock=False, wedgeprops=wedgeprops)
plt.show()
print(ed)

"""17. 값에 따른 생존자와 사망자를 하나의 막대그래프로 나타내시오.(아래:생존자, 위:사망자)"""

en = len(ed_values)
e_datas = df.Embarked.fillna('N')
e_alive_arr = np.zeros(en)
e_dead_arr = np.zeros(en)

for i, e in enumerate(e_datas):
  idx = 0
  for emi in range(en):
    if ed_values[emi] == e:
      idx = emi
      break

  if sur_data[i] == 0:
    e_dead_arr[idx] += 1
  else :
    e_alive_arr[idx] += 1

plt.bar(ed_values, e_alive_arr)
plt.bar(ed_values, e_dead_arr, bottom=e_alive_arr)
for i in range(en):
  plt.annotate(str(e_alive_arr[i]), (-0.3+i, 40))
  if e_alive_arr[i] < 40:
    plt.annotate(str(e_dead_arr[i]), (-0.3+i, e_alive_arr[i]+80))
  else:
    plt.annotate(str(e_dead_arr[i]), (-0.3+i, e_alive_arr[i]+30))
plt.show()

e_alive_arr, e_dead_arr