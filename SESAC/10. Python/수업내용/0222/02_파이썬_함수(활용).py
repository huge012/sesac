# -*- coding: utf-8 -*-
"""02.파이썬 - 함수(활용).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PzZNmvD32xgU-NHvr6eV1LtRv2tVyRTE

# 함수를 활용했을 때의 장점
n개의 정수를 입력받아 합계와 평균을 출력하자.
"""

n = int(input("입력 받을 정수 갯수 : "))
numbers = []
for i in range(n):
  number = int(input(f"{i+1}번째 : "))
  numbers.append(number)

s = 0
for number in numbers:
  s += number

print(f"합계: {s} 평균: {s/len(numbers):.2f}")

def input_numbers(n):
  numbers=[]
  for i in range(n):
    number = int(input(f"{i+1}번째 : "))
    numbers.append(number)
  return numbers

def get_sum(numbers):
  s = 0
  for number in numbers:
    s += number
  return s

n = int(input("입력 받을 정수 개수 : "))
numbers = input_numbers(n)
s = get_sum(numbers)
print(f"합계:{s} 평균:{s/len(numbers):.2f}")

"""# 팁
하드코딩과 소프트코딩

- 0, -1, 1을 제외한 숫자는 변수에 담아서 사용하자

- 파이썬의 경우 상수(변경할 수 없는 변수)가 존재하지 않음
"""

# 파이를 3.14로 하드 코딩
def get_circle_area(radius):
  return 3.14*radius**2

print(get_circle_area(1))

# 상수를 이용한 소프트 코딩
PI = 3.14
def get_circle_area2(radius):
  return PI*radius**2

print(get_circle_area2(1))

s1 = "hello"
s2 = "yahoo"
print("<p>", s1, "</p>")
print("<p>", s2, "</p>")

def make_ptag(s):
  return str.format("<p>{0}</p>", s)
print(make_ptag(s1))
print(make_ptag(s2))

"""# 재귀함수
자기 자신을 호출하여 문제를 해결하는 함수

탈출 조건을 필히 명시해야 함


1. 피보나치 수열

  1 1 2 3 5 8 13 ...

  F(1)=F(2)=1

  F(n)=F(n-1)+F(n-2)

  단, n은 자연수
"""

cnt = 0
def fibonacci(n):
  global cnt # 앞으로 이 함수에서 cnt는 함수 외부에 있는 전역변수 cnt를 의미합니다.
  cnt += 1 # 이 함수가 몇 번 호출하는지 카운팅
  if (n < 0):
    return 0
  if (n == 1) or (n == 2):
    return 1
  return fibonacci(n-1) + fibonacci(n-2)

fibonacci(40)
print(cnt)

re = fibonacci(3)
print(f"fibonacci({3}):{re}")
re = fibonacci(0)
print(f"fibonacci({0}):{re}")

for i in range(1, 20):
  re = fibonacci(i)
  print(re, end=' ')

"""2. 하노이의 탑

  n개의 돌을 A에서 C로 옮기시오(B를 이용)

  규칙 1. 한 번에 하나씩 옮길 수 있다.

  규칙 2. 큰 돌 위에 작은 돌을 올릴 수 있다.


  가정)

  1) n-1개를 A -> B

  2) 1개를 A -> C

  3) n-1개를 B -> C

  1), 2), 3)에 의해 n개를 옮길 수 있다
"""

cnt = 0
def hanoi(a, b, c, n):
  
  if n == 0:
    return
  hanoi(a, c, b, n-1) # A에 있는 n-1개의 돌을 B로 옮겨라 (C 이용)
  print(f'{a}->{c}') # A에 있는 1개의 돌을 C로 옮겨라
  hanoi(b, a, c, n-1) # B에 있는 n-1개의 돌을 C로 옮겨라 (A이동)

hanoi('a', 'b', 'c', 3)

"""# 동적 프로그래밍 (Dynamic Programming)

경험한 정보를 이용하여 문제를 해결하는 최적화 기법
"""

cnt2 = 0
answer=[0, 1, 1]
def fibonacci2(n):
  global cnt2
  cnt2 += 1
  if len(answer) > n:
    return answer[n]
  re = fibonacci2(n-1) + fibonacci2(n-2)
  answer.append(re)
  return re

for i in range(1, 20):
  re = fibonacci2(i)
  print(re, end=' ')

fibonacci2(40)
print(cnt2)

def fibonacci(n):
  if (n < 0):
    return 0
  if (n == 1) or (n == 2):
    return 1
  return fibonacci(n-1) + fibonacci(n-2)

def fibonacci2(n):
  if len(answer) > n:
    return answer[n]
  re = fibonacci2(n-1) + fibonacci2(n-2)
  answer.append(re)
  return re

import time

def test_case(n):
  print("test case: ", n)
  start = time.time()
  fibonacci(n)
  end = time.time()
  print("fibonacci : ", end-start)
  start2 = time.time()
  fibonacci2(n)
  end2 = time.time()
  print("fibonacci2 : ", end2-start2)
  print()

for i in range(1, 25):
  test_case(i)