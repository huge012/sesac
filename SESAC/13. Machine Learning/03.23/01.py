# -*- coding: utf-8 -*-
"""01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d0uAG6Tmln9NDXElXdqUImcYbAkUgMop
"""

# Commented out IPython magic to ensure Python compatibility.
# %run my_init.py

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

fish = pd.read_csv("https://bit.ly/fish_csv_data")
fish.head()

fish.columns # feature 확인

# X, y 데이터를 만들어 봅시다
fish_input = fish.drop('Species', axis = 1) 
fish_target = fish['Species'].to_numpy()

fish_input.shape, fish_target.shape

# train / test set 만들기
train_input, test_input, train_target, test_target = train_test_split(fish_input, fish_target, random_state = 42)

train_input.shape, train_target.shape

test_input.shape, test_target.shape

# 전처리 과정으로 변환기를 이용한 스케일링을 한다
ss = StandardScaler()
train_scaled = ss.fit_transform(train_input)
test_scaled = ss.transform(test_input)

# 확률적 경사하강법을 적용 - 하나씩 샘플을 빼서 진행
sc = SGDClassifier(loss='log', random_state=42, max_iter = 10, verbose = 0)
sc.fit(train_scaled, train_target)

# 정답과 예측한 클래스로 모형을 평가 - 1 에포크 끝
print(accuracy_score(train_target, sc.predict(train_scaled))) # 엘라스틱 넷
print(accuracy_score(test_target, sc.predict(test_scaled)))

sc.partial_fit(train_scaled, train_target, classes = np.unique(train_target))
print(accuracy_score(train_target, sc.predict(train_scaled)))
print(accuracy_score(test_target, sc.predict(test_scaled)))

# 에포크와 언더피트/오버피트 관계 살펴보기
sc = SGDClassifier(loss = 'log', random_state=42)
classes = np.unique(train_target)
train_score, test_score = [], []

for _ in range(300):
  # 이미 위에서 fit을 했기때문에 classes=np.unique(train_target) 안해도 클래스 정보는 알 수 있음
  sc.partial_fit(train_scaled, train_target, classes = classes)
  train_score.append(accuracy_score(train_target, sc.predict(train_scaled)))
  test_score.append(accuracy_score(test_target, sc.predict(test_scaled)))

plt.plot(train_score)
plt.plot(test_score)
plt.xlabel('epoch')
plt.ylabel('accuracy')
plt.legend(['train', 'test'])
plt.show()

sc = SGDClassifier(loss='log', max_iter=100, random_state=42, tol=None)
sc.fit(train_scaled, train_target)
print(accuracy_score(train_target, sc.predict(train_scaled)))
print(accuracy_score(test_target, sc.predict(test_scaled)))

from sklearn.linear_model import SGDRegressor

?SGDRegressor