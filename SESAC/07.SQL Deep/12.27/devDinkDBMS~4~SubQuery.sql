/* Sub Query */

SELECT ENAME,JOB FROM EMP;

/* Sub Query 종류 - 리턴타입 1. SINGLE COLUMN, SINGLE ROW */
SELECT ENAME,JOB FROM EMP
WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME = 'SMITH' );
SELECT ENAME,SAL FROM EMP WHERE SAL < ( SELECT AVG(SAL) FROM EMP);

/* Sub Query 종류 - 리턴타입 2. SINGLE COLUMN, MULTIPLE ROW RETURN SUBQUERY */
-- SELECT ENAME,JOB FROM EMP WHERE DEPTNO = 10,30; -- =은 단일연산자, 두 개 값 다 쓰려면 IN( , )
SELECT ENAME,JOB FROM EMP WHERE DEPTNO IN ( 10,30 ); -- Multiple Rows
SELECT DNAME,LOC FROM DEPT -- 3명 이상 근무 하는 부서의 정보
WHERE DEPTNO = (SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*) > 3 ); 

/* Sub Query 종류 - 리턴타입 3. MULTIPLE COLUMN, MULTIPLE ROW RETURN */
SELECT DEPTNO,JOB,ENAME,SAL FROM EMP
WHERE (DEPTNO,JOB) IN (SELECT DEPTNO,JOB FROM EMP
GROUP BY DEPTNO,JOB HAVING AVG(SAL) > 2000);

SELECT DEPTNO,JOB FROM EMP GROUP BY DEPTNO,JOB HAVING AVG(SAL) > 2000;

/* Sub Query 종류 - 위치 1. Scalar Subquery - SELECT절에 오는 서브 쿼리, 결과값 1행만 반환, 반복수행하게 됨 */
SELECT DEPTNO, ENAME, JOB, SAL, (SELECT ROUND(AVG(SAL), 0) FROM EMP S WHERE S.JOB=M.JOB) AS JOB_AVG_SAL -- 직업별 평균 급여 반환
FROM EMP M
ORDER BY JOB;

/* Sub Query 종류 - 위치 2. In-Line View - FROM절에 사용된 SubQuery */
SELECT DEPTNO, ENAME,EMP.JOB,SAL,IV.AVG_SAL
FROM EMP, (SELECT JOB,ROUND(AVG(SAL)) AS AVG_SAL FROM EMP GROUP BY JOB ) IV
WHERE EMP.JOB = IV.JOB AND SAL > IV.AVG_SAL
ORDER BY DEPTNO ,SAL DESC;

/* Sub Query 종류 - 위치 3. Nested Subquery - WHERE절에 사용된 SubQuery*/
SELECT ENAME,JOB FROM EMP WHERE DEPTNO IN ( 10,30 ); -- Multiple Rows
SELECT DNAME,LOC FROM DEPT -- 3명 이상 근무 하는 부서의 정보
WHERE DEPTNO = (SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*) > 3 ); 


/* Sub Query 종류 - 동작방식 1. Correlated SubQuery - Main의 정보를 참조해서 Sub 쿼리 수행하여 반환 */
SELECT DEPTNO, ENAME, JOB, SAL FROM EMP M
WHERE SAL > ( SELECT AVG(SAL) AS AVG_SAL FROM EMP WHERE JOB = M.JOB );

/* Sub Query 종류 - 동작방식 2. Normal SubQuery - Main의 정보를 참조하지 않음 */
-- 예제 x


/* TOP-N, BOTTOM-M - 상위 N, 하위 N */
SELECT * 
FROM ( SELECT EMPNO,ENAME,SAL FROM EMP ORDER BY SAL ASC) BM
-- In-Line View 테이블을 동적으로 만들 수 있음, 
WHERE ROWNUM <= 5; -- 가장 적은 급여 받는 5명

SELECT TN.EMPNO,TN.ENAME,TN.SAL 
FROM (SELECT EMPNO,ENAME,SAL FROM EMP ORDER BY SAL DESC) TN
WHERE ROWNUM < 5; -- 가장 많은 급여 받는 5명

select * from emp;
SELECT * FROM BONUS;

/* SubQeury와 DML */
-- SUBQUERY로 한번에 N개 Rows INSERT
INSERT INTO BONUS(ENAME, JOB, SAL, COMM) SELECT ENAME, JOB, SAL, COMM FROM EMP;
-- SELECT로 임의 테이블 만들어서 한 번에 INSERT
SELECT * FROM BONUS;
ROLLBACK;
SELECT * FROM BONUS;

-- 부서별 성과별 보너스 계산 후 N개 Row INSERT
INSERT INTO BONUS(ENAME, JOB, SAL, COMM)
SELECT ENAME, JOB, SAL, DECODE(DEPTNO, 10, SAL*0.3, 20, SAL*0.2) + NVL(COMM, 0)
FROM EMP WHERE DEPTNO IN (10, 20);

SELECT * FROM BONUS;
COMMIT;


-- 평소 COMM을 받지 못하는 사원들에게 평균 COMM 금액의 50%를 보너스로 지급
UPDATE EMP SET COMM = (SELECT AVG(COMM)/2 FROM EMP) WHERE COMM IS NULL OR COMM = 0;
COMMIT;

-- 평균 이상의 급여를 받는 사원들은 보너스 지급 대상자에서 제외
DELETE FROM BONUS WHERE SAL > (SELECT AVG(SAL) FROM EMP);
COMMIT;

INSERT INTO EMP VALUES (8010, 'KIM', 'CLERK', 7901, NULL, 2200, 300, 40);

/* JOIN */

SELECT EMPNO,ENAME,SAL,DEPTNO FROM EMP;
SELECT DEPTNO,DNAME,LOC FROM DEPT;
SELECT DNAME, ENAME,SAL FROM DEPT , EMP
WHERE DEPT.DEPTNO = EMP.DEPTNO ;

/* Equi-Join */

-- SELECT DNAME, ENAME, JOB, SAL FROM EMP, DEPT WHERE DEPTNO = DEPTNO; -- 어느 DEPTNO인지 명시 필요
SELECT DNAME, ENAME, JOB, SAL FROM SCOTT.EMP, SCOTT.DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO;

SELECT DNAME, ENAME, JOB, SAL FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND EMP.JOB IN ('MANAGER', 'CLERK');

SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO;

SELECT D.DNAME, E.ENAME, E.JOB, E.SAL FROM EMP E INNER JOIN DEPT D ON E.DEPTNO = D.DEPTNO;

SELECT D.DNAME,E.ENAME,E.JOB,E.SAL FROM EMP E INNER JOIN DEPT D 
ON E.DEPTNO = D.DEPTNO -- 조인 조건
WHERE E.DEPTNO IN (10,20) AND D.DNAME = 'RESEARCH';


/* Non Equi-Join */
SELECT E.ENAME, E.JOB,E.SAL,S.GRADE FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; -- 범위 연산자

SELECT * FROM EMP;

SELECT DNAME,ENAME,JOB,SAL,GRADE 
FROM EMP E, DEPT D, SALGRADE S 
WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL; 
-- 3개 테이블 JOIN , 최소 JOIN조건: N(테이블개수) – 1
SELECT E.ENAME, E.JOB, E.SAL, S.GRADE FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND E.DEPTNO IN (10,30)
ORDER BY E.ENAME;
-- 조건절 처리 순서?? (a) JOIN 처리 (E.SAL BETWEEN S.LOSAL AND S.HISAL) → 필터링 (E.DEPTNO IN (10,30))
-- (b) 필터링 → JOIN 처리
SELECT E.DEPTNO, E.ENAME, E.JOB,E.SAL,S.GRADE
FROM EMP E, SALGRADE S
WHERE E.SAL < S.LOSAL AND E.DEPTNO IN (10,30)
ORDER BY E.ENAME;


/* OUTER - JOIN : 조건에 만족되지 않는 정보도 조회 */
SELECT D.DNAME,E.ENAME,E.JOB,E.SAL FROM EMP E,DEPT D WHERE E.DEPTNO = D.DEPTNO
ORDER BY D.DNAME;
-- 40번 부서에 근무하는 직원이 없기 때문에 Equi Join에서는 40번 부서관련 정보 조회가 안된다.
SELECT D.DNAME,E.ENAME,E.JOB,E.SAL FROM EMP E,DEPT D WHERE E.DEPTNO(+) = D.DEPTNO 
ORDER BY D.DNAME; 
-- 기준되는 테이블(DEPT)과 조인되는 반대편 테이블(EMP)의 조인 조건에 (+) 표시 , 직접 매핑되지 않는 컬럼에는 NULL
 SELECT D.DNAME,E.ENAME,E.JOB,E.SAL FROM EMP E,DEPT D WHERE E.DEPTNO = D.DEPTNO(+) 
ORDER BY D.DNAME;
-- Equi-Join과 동일한 결과 출력, 불필요한 아웃터 조인은 비효율적인 자원 사용 가능
SELECT D.DNAME,NVL(E.ENAME,'비상근 부서'),E.JOB,E.SAL FROM EMP E,DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY D.DNAME; 
-- 직접 매핑되지 않는 컬럼에는 NULL
-- SELECT D.DNAME,E.ENAME,E.JOB,E.SAL FROM EMP E,DEPT D WHERE E.DEPTNO(+) = D.DEPTNO(+)
-- ORDER BY D.DNAME; -- 양방향 OUTER JOIN 안됨


/* Self-Join - 같은 테이블끼리 조인 */
SELECT E.ENAME||' ''S MANAGER IS '||M.ENAME 
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO
ORDER BY M.ENAME;


/* 카티션 곱 */
SELECT ENAME,JOB,DNAME FROM EMP, DEPT; 
-- Join 조건 생략시 발생 , 데이터 건수 체크

SELECT ENAME,JOB,DNAME FROM EMP , DEPT 
WHERE EMP.SAL > 2000 and DEPT.DEPTNO IN (10,20); 
-- 필터링 조건(O) , Join 조건(X) , and 와 데이터 건수 체크

SELECT ENAME,JOB,DNAME FROM EMP , DEPT 
WHERE EMP.SAL > 2000 or DEPT.DEPTNO IN (10,20); 
-- 필터링 조건(O) , Join 조건(X) , or 와 데이터 건수 체크

SELECT E.ENAME, E.JOB,E.SAL,S.GRADE FROM EMP E, SALGRADE S
WHERE E.SAL < S.LOSAL AND E.DEPTNO IN (10,30)
ORDER BY E.ENAME;
-- 잘못된 JOIN 조건

SELECT * FROM DEPT;