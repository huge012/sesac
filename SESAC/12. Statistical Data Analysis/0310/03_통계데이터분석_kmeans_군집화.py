# -*- coding: utf-8 -*-
"""03. 통계데이터분석 - KMeans 군집화.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jogicxKhlkYmRUaQXgVT18hoLbgnHaIA

KMeans
- 거리가 가까운 데이터를 비슷한 집단으로 묶어서 K개의 집단으로 분류하는 방법


    k개로 군집화
    1. 3개의 중심점 선택
    2. 모든 점을 중심점에 맞춰 묶음
    3. 3개의 중심점과 거리 계산하여 군집화
    4. 중심점 계산 후 3번으로 돌아감
    5. 3, 4를 반복하다가 모든 군집이 변화 없을 때 멈춤
"""

def distance(x1, x2):
  return sum((x1-x2)**2)**(1/2)

import numpy as np
na1 = np.array([1, 2])
na2 = np.array([5, 5])
print(distance(na1, na2))

def kmeans(data, k=3):
  centers = []
  dl = len(data)
  # 초기에 k개의 중심점을 선택한다 (무엇을 중심점으로 선택하는 것인지 좋은지는 생략)
  for center in range(k):
    ci = np.random.randint(dl) # 현재 데이터 중 무엇을 선택할 것인지 인덱스 결정(ci는 선택 인덱스)
    centers.append(data[ci])  # 선택한 점을 초기 중심점으로 결정
  print(centers)
  
  while True:  # 반복
    # 모든 데이터를 중심점과의 거리를 계산하여 가까운 중심점 그룹에 속하게 한다.
    cs = {}
    for elem in data:  # 모든 점들을
      distances = []
      for i in range(k):  # 모든 중심점들과
        dis = distance(centers[i], elem)  # i번째 중심점과 elem 사이의 거리를 계산한다.
        distances.append(dis)
      nd = np.array(distances)
      ai = nd.argmin()  # 최소 거리에 해당하는 인덱스를 구하여라 (그룹 인덱스)
   
      if ai in cs:  # 해당 인덱스가 처음 선택한 인덱스일 때
        cs[ai].append(elem)  # 해당 그룹에 해당 elem(점)을 소속시킨다.
      else:  # 그렇지 않다면
        cs[ai] = [] # 사전 객체에 elem을 초기 원소로 하는 배열 생성
        cs[ai].append(elem) # 리스트에 elem을 소속시킨다

    # 그룹의 중심점을 계산한다
    rcenters = []
    for i in range(k):  # k개의 그룹에 관하여
      sx = np.array([x for x, _ in cs[i]])
      sy = np.array([y for _, y in cs[i]])
      rcenters.append([sx.mean(), sy.mean()])
    # 만약 이전 중심점과 새로운 중심점이 서로 같으면
    if np.array_equal(centers, rcenters):
      break # 루프 탈출
    else:
      centers = rcenters
  return cs

from numpy.core.numeric import array_equal
a = np.array([1, 2, 3])
b = np.array([1, 2, 3])
np.array_equal(a, b)

# 50개의 랜덤 좌표 데이터
data = np.array([ [np.random.randint(0, 100), np.random.randint(0, 100)] for _ in range(50) ])
len(data)

re_cl = kmeans(data)

import matplotlib.pyplot as plt
plt.plot(np.array([x for x, _ in re_cl[0]]), np.array([y for _, y in re_cl[0]]), 'b.')
plt.plot(np.array([x for x, _ in re_cl[1]]), np.array([y for _, y in re_cl[1]]), 'ro')
plt.plot(np.array([x for x, _ in re_cl[2]]), np.array([y for _, y in re_cl[2]]), 'g*')
plt.show()