# -*- coding: utf-8 -*-
"""03.통계데이터분석 - Text Mining 관련 알고리즘.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TFc0Pz-m1JQwFoSZgxUcRbZzOuaj7ZEZ

언휴는 eh 도서관의 사서입니다.
고객이 많아지면서 언휴에게 책을 찾아달라는 요청도 많아졌어요.
이제 원하는 책을 찾는 것을 프로그램으로 제작해 보려고 합니다.

책을 찾을 때 원하는 질의를 입력하면 연관성이 높은지 점수를 부여할 거예요.
점수는 책 내에 질의가 나오는 빈도와 질의의 희귀도를 조합하에 계산합니다.


예를 들어 책 A에 전체 단어 수가 100개이고 질의가 3번 나오면 빈도 점수는 3/100입니다.

    빈도 점수 = 질의 빈도/책에 단어 수

전체 책이 50권이고 질의를 포함하는 책이 6권이면 희귀도는 log2(50/(6+1))입니다.

	  희귀도 = log2((전체 책 수+1)/(질의 포함 책 수+1))

log2는 밑수가 2인 로그를 의미합니다.


책에 부여하는 연관성 점수는 희귀도 점수가 0일 때는 빈도 점수입니다.

    연관성 점수 = 빈도 점수 : 희귀도 점수가 0일 때

희귀도 점수가 0이 아닐 때는 빈도 점수 X 희귀도 입니다.

    연관성 점수 = 빈도 점수 X 희귀도 :희귀도 점수가 0이 아닐 때

입력은 책 내용 목록(문자열을 원소로 하는 리스트)와 검색 질의(문자열)이 주어집니다.

출력(반환)은 점수 목록입니다.

단어는 공백을 기준으로 구분합니다.


입력: ["abc korea bbc dde zzz","abc hello yahoo","korea python korea yahoo abc",
			 "hello korea","yahoo","hello","world"],"korea"

출력: [0.2, 0.0, 0.4, 0.5, 0.0, 0.0, 0.0]

def ranking(books,query): 
   #구현하시오
   return None
"""

import math

def ranking(books,query):
  # DF 값을 구한다
  dcnt = len(books)# 문서 개수를 구한다
  # 질의를 포함하는 문서 개수를 구한다
  dref = 0
  for book in books:
    if query in book:
      dref += 1
  # idf(희귀도)값을 산출한다 log2((전체 책 수+1)/(질의 포함 책 수+1))
  idf = math.log((dcnt+1)/(dref+1), 2)
  print(idf)

  # 모든 책들에 대한 TF 값을 구한다
  scores = []  # score값을 보관할 컬렉션
  # 반복(모든 책들을 순차적으로)
  for book in books:
    # 책의 내용을 단어별로 분리
    svs = str.split(book)
    # 반복(해당 책의 모든 단어를 순차적으로)
    tref = 0  # 참조(단어) 카운터를 0으로 초기화
    for word in svs:
      # 질의와 단어가 일치하면 카운터 증가
      if word == query:
        tref += 1
    # tf값을 계산
    tf = tref/len(svs)

    # tf * idf 값을 계산
    score = tf*idf
    scores.append(score)

  return scores  # 결과를 반환한다

re = ranking(["abc korea bbc dde zzz","abc hello yahoo","korea python korea yahoo abc","hello korea","yahoo","hello","world"],"korea") 
print("결과:",re)
print("정답:",[0.2, 0.0, 0.4, 0.5, 0.0, 0.0, 0.0])