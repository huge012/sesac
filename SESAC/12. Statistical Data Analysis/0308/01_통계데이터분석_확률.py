# -*- coding: utf-8 -*-
"""01. 통계데이터분석 - 확률.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zQcgR6I5ZgeExiqwn9lVnPezMZZ7lN3b

로지스틱 회귀는 이벤트가 발생할 확률을 결정하는 데 사용되는 통계 모델입니다. 특성 간의 관계를 보여주고 특정 결과의 확률을 계산합니다.
"""

import enum, random
class Coin(enum.Enum):
  FRONT=0
  BACK=1
  def random_coin():
    return random.choice([Coin.FRONT, Coin.BACK])

for _ in range(20):
  if Coin.random_coin() == Coin.FRONT:
    print(".", end=' ')
  else:
    print("1", end=' ')

"""만약에 동전을 두 번 던졌을 때 P(both|first)와 P(both|either)를 구하시오.

P(both|first) 첫 번째 던졌을 때 뒷면이 나오고 둘 다 뒷면이 나올 확률

P(both|either) 둘 중 하나가 뒷면이 나오고 둘 다 뒷면이 나올 확률
"""

both_back = 0 #둘다 뒷면이 나온 횟수
first_back=0 #첫번째 뒷면이 나온 횟수
either_back=0 #둘 중 하나는 뒷면이 나온 횟수

for _ in range(10000):
  first=Coin.random_coin()
  second=Coin.random_coin()
  if first == Coin.BACK:
    first_back +=1
  if first == Coin.BACK and second == Coin.BACK:
    both_back +=1
  if first==Coin.BACK or second == Coin.BACK:
    either_back +=1
print("P(both|first)",both_back/first_back) #첫번째가 뒷면이 나오고 나머지 두개가 둘다 뒷면이 나올 확률
print("P(both|either)",both_back/either_back)

def uniform_pdf(x): #균등 분포
  if 0<=x<1:
    return 1
  return 0

def uniform_cdf(x): #누적 분포
  if x<0:
    return 0
  if x<1:
    return x
  return 1

xs = []
pys=[]
cys=[]
#-1~-2까지 step=0.01로 균등 분포와 누적 분포를 계산하여 컬렉션에 보관
for x_100 in range(-100,200):
  pys.append(uniform_pdf(x_100/100))
  cys.append(uniform_cdf(x_100/100))
  xs.append(x_100/100)

import matplotlib.pyplot as plt
fig,ax=plt.subplots(1,2)
ax[0].plot(xs,pys,"b.",label="pdf")
ax[1].plot(xs,cys,"r.",label="cdf")
ax[0].set_title("The uniform pdf")
ax[1].set_title("The uniform cdf")
plt.show()

"""![KakaoTalk_20220308_101020131.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASgAAABtCAYAAAAS5fxyAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABpCSURBVHhe7d0HmFxl9QZwFKVYiNIMggoqItUIqIiJIII1GBSlCNIFgqKixhbBEhWpKnaCBaICIlWRJk2KARsKigrYAHuvIOX7P78vc/nfDLM7O7s7996ZPe/z3GeTu7uzU777fue85z3nLpMCgUCgoQiCCgQCjUUQVCAQaCyCoAKBQGMRBBUIBBqLIKhAINBYBEEFAoHGIggqEAg0FkFQgUCgsQiCCgQCjUUQVCAQaCyCoAKBQGMRBBUIBBqLIKhAINBYBEEFAoHGIggqEAg0FkFQgUCgsQiCCkwKfvnLX6Zvf/vb6fbbb2+dCQwS/vnPf6Yf/ehH6dprr22daQaCoAITxi9+8Yv04Q9/OB133HHpz3/+c+tsoC7cdttt6atf/Wo65phj0gc/+MH0ta99Lf373/9ufbcz/vOf/6Qrr7wyHXjggXmjufvuu1vfqRdBUIEJ4Y477kgf//jH0+tf//p0/vnnp//973+t7wTqwO9///t00UUXpVNPPTUT04c+9KH0spe9LH3qU58a9bO555578kazYMGCtOuuu+aN5t577219tz4EQQUmhEsuuSS95jWvSZ/4xCfS3/72t9bZQF3webzhDW/IhCQK+uEPf5h22GGHtOmmm6bf/OY3mYhGwp133pmuu+66/PM2nb///e+t79SHIKjAuHHzzTfnyMmu+5Of/KR1NlAnzjvvvPTKV74yvf/978//F1F94AMfSA95yEPS9773va4RrlRPerjVVluliy++uGtq2G8EQQXGBQv58MMPT3vssUdOKerCXXfdlQX6qaB9ea1/+tOf0q9+9avWmftDkeLss8/O5AK/+93v0vve9760yiqrpOuvvz4/Rjf897//TXvvvXfaf//9s3Bepx4VBBUYF6666qr07Gc/O330ox9Nf/jDH1pnq8dPf/rT/BwWL17cOjO8EM1cfvnlWVcaCyEjo+9+97tp++23z4dNZSxASH7vqU99avrkJz9Z6+cbBBXoGf/617/SS1/60vT85z8/XX311a2z1eMf//hHetOb3pSrVdLNqYDvfOc76aCDDkqf+cxnRiUcArdq3kc+8pE0a9asdOONN46qP3WCCMrv1ln8CIIK9AQL9fOf/3xaffXVc+Tyxz/+sfWdauECREz0lqkQPRUgZF966aVp8803T2eeeeaIKRuB+ytf+Urad999049//ONMTr1W5b71rW+ljTbaKBdBPEYdCIIK9ARpxtZbb5023njj7JepoxTtb/76179O6623XvriF7/YiGpTlVCNI3wjKdFsO1g/LrjggpwK0qBEml//+tfTD37wg0xwY4XNaM6cOekpT3lKOv3001tnq8VQEZSF+rnPfS5Xlura2YcZFrcU45GPfGR6+9vfXptr3AX4jne8I+24445Z+O01dRl0eP1XXHFFWmONNdKXvvSlpUiKwH3yySfnz+eMM87I0eWFF16YI82//vWvPW8oixYtSjNmzEjvec97atGiBp6gaA+f/vSnc17+whe+MO+q22yzTbRc9AGE2be85S3pEY94RK4SjVV0nUwgI1HBE57whFxF9O+phiKCfNGLXpR23nnnpd4DNoMXv/jF6TGPeUyOfPiffHVddIq2ukHFcPbs2VlkLyqDVWLgCcobeNppp2Vj2ZFHHpmWXXbZNHPmzCwQBiYPKju8TlK75zznObm0X0d6J0Jga1hxxRVzOX20i85z5gOy85dL5Ur1oommQNr829/+tvW/scHzF9WstdZa6ec//3nrbMr/ls5JfYtDlCWaGovFoB3SvHe+852Z5I466qieUsTJwMATlF3ch+vg2QiC6g9cENLnhz/84dlXU9cFzq1+9NFHp+WXXz59//vf7+jRcQ6BfuxjH8s/O2/evPzcCb20FJWtY489tlb/VgGR0PHHH5/e/e53t878P6RmChIqcO1AakgHUX/jG9/IxN0vEOO32GKLtPvuu+drrEoMlQb1s5/9LAiqT+A3eslLXpIdybw4dJA6ICJiDl177bUzCXWC8/w73NTK8apQW265ZXrta1+bo+zXve51+YJzvk6PDyjhK+Vvt912S0Wk3t+99torp2uIqh2iIcT10Ic+NL8m70u/IEvZaaedcvT82c9+tnW2GgRBBbpCWC/a4EaWUrgY6hKmaYvaMJhEO+mMIqyzzjorvfnNb85rQDSFUB/96EenzTbbLEcboqoNNtgg7bPPPjmCqQtICJE+7nGPS/vtt1/r7BLQVhkl9cUp93eCotDDHvawTLz9fh20R9aSgw8+OFcFq0IQVKArRBlG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)
![KakaoTalk_20220308_101211012.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAABmCAYAAAAEYUdBAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABQGSURBVHhe7d0FkBxFH4dhKDQ4wd0J7q4JENzdIRDc3d2DuzsEd9fgLsHd3d2lv3qaG75lc5esnsz0WzUFt7nb25uZX/ffZ6iQSCQKSRJ/IlFQkvgTiYKSxJ9IFJQk/kSioCTxJxIFJYk/kSgoSfyJREFJ4k8kCkoSfyJRUJL4E4mCksSfSBSUJP5EoqAk8ScSBSWJP5EoKEn8iURBSeJPJApK7sX/5Zdfhs8//7zlq0Tiv/z555/h22+/DW+++Wb466+/Wl4tBrkW/xNPPBFOOeWUcPvtt7e8kkj8l7///jt88sknYfPNNw933HFH+Pnnn1v+Jf/kVvwDBw4MBx54YDj22GPDa6+91vJqIjEo33//fTj33HNDnz59wm233Ra/LgLtJv5ffvklvPjii+G0004Lv//+e8urzeGjjz6Kwt9vv/3CU0891fJqItE6dn+CP/TQQ8MGG2wQHnnkkXi/5p2mip+//fjjj4drr702nHXWWWGzzTYLk002Wfjxxx9bvqPx/Pbbb+GMM84IW265ZbjzzjubvtAk8oEF4IMPPgibbrpp2H333cPzzz8f4wF5pqnif/XVV8NJJ50UNtlkk7DsssuGMcccM4w66qjhhx9+aPmOxvPwww+H1VZbLVxyySXh66+/bnk1kaiMZ555JvTu3Tv069cvLgZ5pqniZ0q9/vrr4YUXXggDBgwI88wzT9PEnwVu1lhjjbDXXnvF6G2ifkTAWWrOrYMllZnJvv7mm2/CH3/80fLdHYfP5bM4ymEN/vrrrxVH8w855JCw9NJLh0svvTTXAcB28/mZUc0U/08//RQOOuigMN1004WHHnqoU9yQXR2CInALNwvuqKOOCs8991z49NNPY2RcMLV///7h3XffbfmJjuPtt9+OYr388stbXvk/Tz/9dIz9tLYwtMZbb70Vll9++bDxxhvHn80ruRA/38wFG3fcccOuu+4aA36J+pElOfjgg8O6664bRSUaPuecc4a11lorWlcCqossskg44IADojXQkYjzTD/99KFv377/+Szujdlnnz2ssMIK4cknn2x5dchIES+44ILhmGOOyW3+PxfiF1jcd999w3DDDRdz+ynIVz/fffdd3NUFv5j9rpk0mLjNSiutFJ599tkYHBtppJHCnnvu2aHiZ5q7/tNMM00UawbRsgInmWSSsNtuu0XroFLef//9sM4664RVV101Bq3zSC7E76LONtts8aZkpnb0LpQHHnzwwXD88cfH/4JbdeGFF8brd/jhh8fz7N9lVSotonJdqjkq5aWXXgobbrhhWGCBBcLNN9/c8uo/bgtXsHv37vGzW9Aqhdt4xBFHhLnmmiv+vdV8nq5Clxf/V199FdOIdiQXuJlpxCLBPxbtzs6nEtjtttsudOvWLYrdbsu9svAOSVR2TovEoosuWtVxwgknxN87JAi+Z8+eYZVVVvlPoFeQb5lllgljjTVWuPfee6tO3fk7l1pqqbDiiivmsl6ky4vfqi+NOMUUU4T33nsv97nZjuKzzz4Lc889d5h88sljsVY1fjAr4a677opxg2oOwTYCHhKCkTPPPHPYdttt/y3OsVN/8cUXYeKJJ45xCm5KtVjcdthhh2hViinkjS4tfrvPDTfcEC/wmmuuGVM6icbA7LX7E5D/J/jRRhstBs74wxki/aVftzcWh1122SVMO+200UzP8Pr9998fRh555BioFBCWdpapqBR/t4rUmWaaKQYS81b116XF76YTaR5nnHHCySefnNJ7DcSue9hhh4UTTzwxfPjhhzGNNvTQQ4e999773y5JltbVV1/9b1ygI3jnnXdi9kFE/6KLLmp59R83Rb5+hBFGiPeGzIV/FxCuhltvvTW6FNwQC2Ce6NLi54fZiZQMM+vympLpCOx4E000UYx2O88bbbRRGHHEEcPpp58ehcXPF2OREpP77yjUGxDmrLPOGs4///z4mh360UcfDQsvvHAYdthho8tx/fXXx7qEatJ9UKCmQlX9yDnnnNPyaj5oN/G7QeaYY44ofuZkI6KnavddFO+bx2hsR3LeeedFX1kUXam0XL+cvt2U4G688cZoZhNWR7pb/H35fa6foOLdd98dD0IXqFP7YVHYY489opXCjakGJeL+ZkFD758nmip+JaBvvPFG3DnkjAWLRIvli5lfL7/8cs1WgDTOZZddFi8ufz+Jv224Q27ijz/+OGZHKqmDcN2k8tZee+2w4447xsDqPffcE6vevCZv7hp2pPAFdwX5WH52f/fBcsstFz+vBcvfKkOx3nrrxS7P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)



"""

import math
SQRT_TWO_PI = math.sqrt(2*math.pi)
def normal_pdf(x,mu=0,sigma=1): #정규분포 (mu:평균, sigma:표준편차)
  pre = 1/(sigma*SQRT_TWO_PI)
  post = math.exp(-((x-mu)**2)/(2*(sigma**2)))
  return pre * post

xs=[x/10.0 for x in range(-50,50)]
ys1=[normal_pdf(x,sigma=1) for x in xs]
ys2=[normal_pdf(x,sigma=2) for x in xs]
ys3=[normal_pdf(x,sigma=0.5) for x in xs]
ys4=[normal_pdf(x,mu=1) for x in xs]
plt.plot(xs,ys1,'-',label="mu=0,sigma=1")
plt.plot(xs,ys2,'--',label="mu=0,sigma=2")
plt.plot(xs,ys3,':',label="mu=0,sigma=0.5")
plt.plot(xs,ys4,'-.',label="mu=1,sigma=1")
plt.legend()
plt.show()

def normal_cdf(x,mu=0,sigma=1): #정규누적분포
  return(1+math.erf((x-mu)/(sigma*math.sqrt(2))))/2

xs=[x/10.0 for x in range(-50,50)]
ys1=[normal_cdf(x,sigma=1) for x in xs]
ys2=[normal_cdf(x,sigma=2) for x in xs]
ys3=[normal_cdf(x,sigma=0.5) for x in xs]
ys4=[normal_cdf(x,mu=1) for x in xs]
plt.plot(xs,ys1,'-',label="mu=0,sigma=1")
plt.plot(xs,ys2,'--',label="mu=0,sigma=2")
plt.plot(xs,ys3,':',label="mu=0,sigma=0.5")
plt.plot(xs,ys4,'-.',label="mu=1,sigma=1")
plt.legend()
plt.show()

"""베르누이 시행"""

def bernouli_trial(p):
  return 1 if random.random()<p else 0

cnt=0
for _ in range(1000):
  re = bernouli_trial(1/6)
  print(re,end='.') #확률이 1/6인 사건이 발생하면 1, 발생하지 않으면 0 출력
  if re ==1:
    cnt+=1
print()
print(cnt)

def binomial(n,p):
  return sum(bernouli_trial(p) for _ in range(n))

for _ in range(20):
  print(binomial(100,1/6),end='.') #주사위를 100번 던졌을 때 숫자 1이 나올 횟수

from collections import Counter

def binomial_histogram(p,n,nps): #p:확률 n:시도할 횟수 nps(p,n)을 시도할 횟수
  data = [binomial(n,p) for _ in range(nps)]
  #print(data)
  #print(len(data))
  histogram = Counter(data)
  #print(histogram.values())
  #print(histogram.keys())
  #print([v/nps for v in histogram.values()])
  mu = p*n
  sigma = math.sqrt(n*p*(1-p))
  xs = range(min(data),max(data)+1)
  ys = [normal_cdf(i+0.5,mu,sigma)-normal_cdf(i-0.5,mu,sigma) for i in xs]
  #ys2 = [normal_pdf(i, mu, sigma) for i in xs]
  plt.bar(histogram.keys(),[v/nps for v in histogram.values()],color='green')
  plt.plot(xs,ys)
  #plt.plot(xs,ys2)
  plt.show()

binomial_histogram(1/6,100,1200)

"""주사위를 100번 던졌을 때 1이 나오는 횟수가 5~10일 확률은 얼마인가?

0 ~ 10 나올 확률의 합
0 ~ 5 나올 확률의 합

10 정규분포 - 5 정규분포
"""

p = 1/6  # 확률
n = 100  # 시행횟수
mu = p*n # 평균 기대값
sigma = math.sqrt(n*p*(1-p))

c1 = normal_cdf(13, mu=mu, sigma=sigma)  # 정규누적분포
c2 = normal_cdf(18, mu=mu, sigma=sigma)  # 정규누적분포
print(c1, c2)
print(c2-c1)
xs = [x for x in range(101)]
ys = [normal_cdf(x, mu=mu, sigma=sigma) for x in xs]
plt.plot(xs, ys)

import numpy as np
def sigmoid(x): #시그모이드 함수, 로지스틱 함수와 같은 함수이다.
  return 1/(1+np.e**(-x))

xs = range(1-10,10)
ys = [sigmoid(x) for x in xs]
plt.plot(xs,ys,marker='.')
plt.axvline(x=0,color='black')
plt.axhline(y=0,color='red')
plt.axhline(y=1,color='green')
plt.show()

def gradient(y,x,w,b):
  wd = x*(sigmoid(w*x+b)-y)
  bd = (sigmoid(w*x+b)-y)
  return wd,bd

def gradient_descent(xs,ys,lr=0.001,epochs=100):
  if isinstance(xs,list):
    xs = np.array(xs).reshpae(-1)
  wbhl = [] # 학습 과정에서의 가중치와 편향을 보관하기 위함  

  wp = np.random.uniform(-1,1) #초기 가중치를 랜덤하게 결정
  bp = np.random.uniform(-1,1) #초기 편향

  for epoch in range(epochs):
    for i,x in enumerate(xs):
      wd,bd = gradient(ys[i],x,wp,bp) #경사를 구함
      wp = wp - (wd*lr) #가중치를 경사*lr만큼 빼 줌 (곡선의 아래 부분으로 이동)
      bp = bp - (bd*lr) #편향을 경사 *lr만큼 빼줌 (곡선의 아래 부분으로 이동)
    wbhl.append([wp,bp])
  return wp,bp,wbhl

xs=np.arange(-10,10,0.3)
ys=np.array([1 if x>0 else 0 for x in xs])
#ys

wp,bp,wbhl=gradient_descent(xs,ys,epochs=1000)
min_val=min(min(xs),min(ys))
max_val=max(max(xs),max(ys))

for wi in range(len(wbhl)):
  if wi>5 and wi%50!=0:
    continue
  w,b=wbhl[wi]
  pre_ys=[sigmoid(w*x+b) for x in xs]
  plt.figure(figsize=(5,5))
  plt.plot(xs,ys,'b^',label='actual') #실제값을 도면에 뿌림
  plt.plot(xs,pre_ys,'r.',label=f"epoch:{wi} predict w:{w} b:{b}")
  plt.axvline(x=0,color='black')
  plt.axhline(y=0,color='black')
  plt.xlim(min_val,max_val)
  plt.ylim(min_val,max_val)
  plt.legend()
  plt.show()

xs2 = [[x] for x in xs]

from sklearn.model_selection import train_test_split

train_xs, test_xs, train_ys, test_ys = train_test_split(xs2,ys)

len(xs2), len(ys), len(train_xs), len(test_xs),len(train_ys), len(test_ys)

from sklearn.linear_model import LogisticRegression

lr_model=LogisticRegression() #모델 개체 생성
lr_model.fit(train_xs,train_ys)#공부하자
pre_vals=lr_model.predict(test_xs) #예측해라
for i,y in enumerate(test_ys):
  print(f"actual:{y} predict:{pre_vals[i]}")

print(lr_model.score(train_xs,train_ys))
print(lr_model.score(test_xs,test_ys))

"""5<x 일 때 99.7% 확률로 1


2<x<=5 수 일 때 90% 확률로 1


0<x<=2일 때 70% 확률로 1


x<=0일때 0% 확률로 1
"""

xs = np.arange(-10,10,0.3)
ys1 = []
for x in xs:
  if x>5:
    if np.random.uniform(0,10)>0.03: #0~10 사이의 랜덤한 수가 0.03보다 크면
      ys1.append(1)
    else:
      ys1.append(0)
  elif x>2:
    if np.random.uniform(0,10)>1:
      ys1.append(1)
    else:
      ys1.append(0)
  elif x>0:
    if np.random.uniform(0,10)>3:
      ys1.append(1)
    else:
      ys1.append(0)
  else:
    ys1.append(0)

plt.plot(xs,ys1,'.')
plt.show()

"""P(A, B, C, D, ... ) = P(A)P(B)P(C)P(D) ...

로그 취해봄 (로짓 변환)  log P(A,B,C,D, ...) 

    logit(p) = log(p/(1-p)  (p는 사건이 일어날 확률)

중심 극한 정리

베르누이 시행 (균등분포에 해당하는 사건을 정리)
"""